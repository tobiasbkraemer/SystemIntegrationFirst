## Course Slogans

*The right tool for the job*

*pros and cons*

*standards, standards, standards*

*system integration = language agnostic **hmppff***

*Everything but REST*

---

## The course platforms tools

**This Repo**: Code, semester plan, assignment descriptions. 
**Teams**: Communication and hand-ins. @ me so I can see if you have typed a question there. 

Feel free to make PRs. This is the reason why I’ve defined the material in Github.

---

## The Semester Plan

Scroll down to the README to see the slides and the exercises.

---

## System Integration (SI) vs. DLS

The idea is that DLS will be about developing large systems and having these systems running successfully in production. SI is about zooming in on where different type of integration works. 

DLS will be about creating a single cohesive large project throughout the semester and defending it during the exam. 

SI will be about creating multiple stripped down code examples that show how different types of integration work. 

---

## The overall learning goals in SI

The goal is to give you broad knowledge about different technologies, tools, protocols, system constellation. By the end of the course you should feel like you have a tool box and the learning goal is being able to select the correct tool for the job. 

That's why, for each integration you should be able to know the use and downside of the choice. 

For all topics you should be able to at least answer these questions:

* What is it? What is the theory behind it?
* What does it aim to solve?
* How is it an improvement over other things (pros)?
* What complications and downsides does it introduce (cons)? 
* For which use cases would it be a good choice?

This isn’t all there is to know but if you can answer these things then you have a good foundation.

Note: Everything in your education so far has been about REST API. Now it's about everything but. There is nothing wrong with REST APIs but the assumption is that you know them really well by now. 

---

## The structure surrounding the lectures

---

#### Prior to the class

The topics are known in advance. At this educational level you are expected to know how to gather information and evaluate their correctness rather than only engaging with curated material. Create thorough notes. 

Every week there will be a quiz. Take the quiz after you are done researching to evaluate your understanding of the topic. Update the notes after. 

---

#### During the class

Be engaged and join the class discussions!

Why research the topics if we are going to talk about them in class anyway?
- You will be able to develop your own metaphors and ways to understand the course material first.
- You get to process the material multiple times. This shortens the time you need to review the topics prior to the exam. 
- You can have nice discussions when there is pair discussions. 
- You can participate in class. Saying things out loud in front of people will help you remember the topic. Everyone should aim to at least say one thing each week. 

###### Github CoPilot

Feel free to enable CoPilot in class or not. The problem of using it for live coding is that it knows my code well and will suggest code different from you. Shout out during class if I should pause the live coding.

---

#### After the class

Reflect on the learned content, go through the slides and update your notes. Having these notes will make it easy to read up for the exam. 

###### A note about hand-ins

I will not offer individual feedback since your hand-ins are what you will draw for the exam. I am considering a day dedicated to where students can present code snippets and we will discuss it in class. Otherwise, feel free to ask in the Teams channel. 

---

## The overall structure of the semester

The ideal effort put into the course is you prepare continuously. Note that the top part should be non-stressful effort:

[Semester work load](./semester_work_load.png)

---

## Multiple programming languages

In class we will use both Node.js and Python. Why?

The goal of the course is to understand integration from a language agnostic view but completely removing coding from the lectures would make everything too vague. 

By showing solutions in two languages the aim is for us to be able to contrast and compare the solutions. By abstracting the syntax and language specific implementation what should remain is an understanding of the core integration parts. 

For the exam you are welcome to create your own examples in other languages. 

